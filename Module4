public class Module4 {
    public static void main(String[] args) {
        System.out.println("Задача 1: ");
        System.out.println(zadach1("hello my name is Bessie and this is my essay", 10, 7));
        System.out.println("Задача 2: " + zadacha2("((())())(()(()()))"));
        System.out.println("Задача 3: " + toCamelCase("is_modal_open") + ", " + toSnakeCase("getColor"));
        double[] array = new double[]{16, 18, 30, 1.8};
        System.out.println("Задача 4: " + zadacha4(array));
        System.out.println("Задача 5: " + zadacha5("154 pounds", "1.65 meters"));
        System.out.println("Задача 6: " + zadacha6(999));
        System.out.println("Задача 7: " + zadacha7("77777geff"));
        System.out.println("Задача 8: " + zadacha8("You are off to the races.", "a splendid day."));
        System.out.println("Задача 9: " + zadacha9(11133345, 1133368));
        System.out.println("Задача 10: " + zadacha10("$AA$BBCATT$C$$B$", '$'));
    }

    public static String zadach1(String str, int n, int k) {
        int count = 0;
        String sub = "";
        int len = str.length();
        for (int i = 0; i < str.length(); i++) {    // считаем количество пробелов в строке, количество слов в строке будет на одно больше
            char a = str.charAt(i);
            if (a == ' ') {
                count++;
            }
        }
        if (count + 1 != n) {                      // проверка соответствия слов в строке заданному числу слов
            return "Error";
        } else {
            while (len > 0) {                      // выполнять, пока в строке есть элементы
                if (len > k) {                     // если в строке больше символов, чем задано по условию
                    for (int z = k + 1; z > 0; z--) {  // начиная с символа, который стоит на 1 позицию позже максимально
                        char b = str.charAt(z);        // допустимого по условию символа, ищем пробел
                        if (b == ' ') {                // если пробел найден, то записываем в новую строку элементы, начиная
                            sub += str.substring(0, z) + System.lineSeparator();  // с нулевого до пробела и переносим
                            str = str.substring(z + 1, str.length());   // на новую строку все оставшиеся элементы строки
                            len -= (z + 1);     // уменьшаем длину на количество символов, записанных в новую строку + 1, чтобы убрать из строки пробел
                            break;
                        }
                    }
                }
                else {              // если в строке меньше символов, чем задано по условию, то все они переписываются в новую строку
                    sub += str;
                    len = 0;
                }
            }
            return sub;
        }
    }

    public static String zadacha2(String str) {
        String substr = "";
        int index1;
        int index2;
        int count = 0;
        while (str.length() > 1) {                        // пока в строке есть элементы
            index1 = str.indexOf(")");                    // находим место, на котором стоит элемент ")"
            if (index1 == -1) break;                      // если такой элемент не найден, то выходим из цикла
            count += index1;                              // в переменную записываем количество элементов, которые запишем в новую строку
            substr += str.substring(0, index1);           // в новую строку записываем элементы строки с начала до найденного
            str = str.substring(index1, str.length());    // исключаем из начально строки все элементы до найденного
            index2 = str.indexOf("(");                    // находим место, на котором стоит элемент "("
            if (index2 == -1) {                           // если такой элемент не найден, то выходим из цикла
                substr += str.substring(0, str.length()); // в строку записываем элементы строки с начала до найденного
                break;                                    // выходим из цикла
            }
            count -= index2;                              // вычитаем из переменной количество элементов, которые запишем в новую строку
            if ((count == 0)) {                           // после вычитания в переменной останется 0, если количество элементов в первом и втором случае равно
                substr += str.substring(0, index2) + ", ";// если количество элементов равно, то в строку записываем элементы строки с начала до найденного и добавляем запятую
            } else substr += str.substring(0, index2);    // в противном случае просто записываем элементы строки с начала до найденного
            str = str.substring(index2, str.length());    // из начальной строки исключаем элементы до найденного
        }
        return substr;
    }

    public static String toCamelCase(String str) {
        int n = str.length();
        int index;
        while (n - 1 > 0) {             // пока в строке есть элементы
            index = str.indexOf("_");   // находим "_"
            if (index == -1) break;     // если элемента нет в строке, то выходим из цикла. Переписываем строку, исключив из неё "_"
            str = str.substring(0, index) + str.substring(index + 1, index + 2).toUpperCase() + str.substring(index + 2); // букву, стояющую перел "_"  делаем большой
            n -= index;                 // счётчик количества элементов уменьшаем на номер найденного "_"
        }
        return str;
    }

    public static String toSnakeCase(String str) {
        int n = str.length();
        for (int i = 0; i < n; i++) {                    // каждый символ в строке проверяем
            if (Character.isUpperCase(str.charAt(i))) {  // если в строке найдена большая буква, то добавляем перед ней "_"
                str = str.substring(0, i) + "_" + str.substring(i, i + 1).toLowerCase() + str.substring(i + 1); // букву делаем маленькой
            }
        }
        return str;
    }

    public static String zadacha4(double[] array) {
        double result = 0;
        double hours1;
        double hours2;
        String str = "";
        if (array[1] > 17) {                  // сравниваем конец рабочего дня с 17, если больше, то имеется переработка
            hours1 = 17 - array[0];           // находим, сколько часов человек работал до 17
            hours2 = array[1] - 17;           // находим, сколько часов человек работал после 17
            result = array[2] * (hours1 + hours2 * array[3]); // считаем заработок с учетом почасовой оплаты и множителя сверхурочной работы
        } else {
            result = (array[1] - array[0]) * array[2]; // если человек закончил работать до 17, то он не имеет переработки
        }                                              // в таком случае множитель сверхурочной работы не используем
        str += "$ " + Double.toString(result);         // резульат записываем в строку с добавлением знака $
        return str;
    }

    public static String zadacha5(String weight, String height) {
        int n1 = weight.length();
        int n2 = height.length();
        int index1 = weight.indexOf(" ");
        int index2 = height.indexOf(" ");
        double result = 0;
        String sub_w = weight.substring(0, index1); // отделяем число в строке от единиц измерения
        String sub_h = height.substring(0, index2); // оставляем только числа в строке
        double number_w = Double.valueOf(sub_w);    // переводим числа из строки к типу double
        double number_h = Double.valueOf(sub_h);
        if (weight.substring(n1 - 5, n1).equals("kilos")) {      // если вес в кг
            if (height.substring(n2 - 6, n2).equals("meters")) { // и рост в метрах
                result = number_w / (number_h * number_h);       // результат вычисляется по формуле
            } else {
                result = number_w / Math.pow(number_h * 0.025, 2); // если вес в кг, а рост в дюймах, то результат вычисляется по формуле
            }
        } else if (height.substring(n2 - 6, n2).equals("meters")) { // если вес в фунтах, а рост в метрах
            result = number_w * 0.45 / (number_h * number_h);
        } else
            result = number_w * 0.45 / Math.pow(number_h * 0.025, 2); // если вес в фунтах, а рост в дюймах
        if (result >= 25) {
            return "Overweight";
        } else if (result < 18.5) {
            return "Underweight";
        } else return "Normal weight";
    }

    public static int zadacha6(int number) {
        int a = number;
        int result = 10;        // в результат записываем любое число, которое имеет больше одного разряда
        int count = 0;
        while (result > 9) {    // пока в числе больше одного разряда
            result = 1;
            if (a < 10) {       // если число состоит из одного разряда, то выходим из цикла
                break;
            }
            while (a > 0) {         // пока число больше 0
                result *= a % 10;   // в переменной result перемножаем цифры числа a
                a = a / 10;         // из числа a убираем разряд десятков
            }
            count++;                // считаем количество раз, когда мы перемножаем цифры числа
            a = result;             // в a записываем полученное число
        }
        return count;
    }

    public static String zadacha7(String str) {
        String substr = "";
        int count = 1;                                    // счетчик, в который записывается количество раз, которое повторяется каждый элемент
        for (int i = 0; i < str.length(); i++) {          // для каждого элемента в строке
            for (int j = i + 1; j < str.length(); j++) {  // сравниваем его со всеми последующими в строке
                if (str.charAt(i) == str.charAt(j)) {     // если встречается повторяющийся элемент
                    count++;                              // увеличиваем счетчик на 1
                }
            }
            if (count == 1) {                             // если элемент встречается 1 раз в строке, то записываем его в строку без именений
                substr += str.charAt(i);
            } else {                                      // если элемент встречается несколько раз в строке, то записываем его в следующей форме
                substr += str.charAt(i) + "*" + count;    // "элемент*число повторений"
            }
            i += count - 1;                               // переходим к месту, на котором стоит новый элемент
            count = 1;
        }
        return substr;
    }

    public static boolean zadacha8(String str1, String str2) {
        str1 = str1.toLowerCase();
        str2 = str2.toLowerCase();
        char l1;
        char l2;
        int check1 = 0;
        int check2 = 0;
        int check3 = 0;

        // оставляем в первой строке только последнее слово. Тк последний элемент строки - знак препинания, начинаем с предпоследнего элемента
        // ищим первый пробел
        for (int i = str1.length() - 2; i >= 0; i--) {
            if (str1.charAt(i) == ' ') {
                str1 = str1.substring(i + 1, str1.length() - 1);
                break;
            }
        }
        // аналогично для второй строки
        for (int j = str2.length() - 2; j >= 0; j--) {
            if (str2.charAt(j) == ' ') {
                str2 = str2.substring(j + 1, str2.length() - 1);
                break;
            }
        }
        // считаем количество гласных букв в слове из первой строки
        for (int k = 0; k < str1.length(); k++) {
            l1 = str1.charAt(k);
            if ((l1 == 'a') || (l1 == 'u') || (l1 == 'e') || (l1 == 'o') || (l1 == 'y') || (l1 == 'i')) {
                check1++;
            }
        }
        // считаем количество гласных букв в слове из второй строки
        for (int n = 0; n < str2.length(); n++) {
            l2 = str2.charAt(n);
            if ((l2 == 'a') || (l2 == 'u') || (l2 == 'e') || (l2 == 'o') || (l2 == 'y') || (l2 == 'i')) {
                check2++;
            }
        }
        if (check1 != check2) return false; // если количество гласных различно, то выводим false

        // проверяем, чтобы каждой главной букве из первой строки соответсвовала гласная буква во второй строке
        for (int k = 0; k < str1.length(); k++) {
            l1 = str1.charAt(k);
            if ((l1 == 'a') || (l1 == 'u') || (l1 == 'e') || (l1 == 'o') || (l1 == 'y') || (l1 == 'i')) {
                for (int n = 0; n < str2.length(); n++) {
                    l2 = str2.charAt(n);
                    if (l1 == l2) {
                        check3++;
                    }
                }
            }
        }
        return check1 == check3; // проверяем на соответсвие количество гласных букв в каждом слове и количество совпавших гласных букв
    }

    public static boolean zadacha9(int num1, int num2) {
        int a;
        int b;
        int c;
        while (num1 > 0) {              // пока первое число больше 0
            a = num1 % 10;              // записываем в переменную a последнюю цифру числа
            num1 = num1 / 10;           // убираем из числа последнюю цифру
            b = num1 % 10;              // в b записываем следующую за a цифру
            if (a == b) {               // если цифры равны
                num1 = num1 / 10;       // убираем из числа ещё одну цифру
                c = num1 % 10;          // записываем в c следующую за b цифру
                if (a == c) {           // если цифра в a равно цафре в c, то мы нашли три идущие подряд одинаковые цифры
                    while (num2 > 0) {  // аналогично проверяем второе число до совпадения в нём двух
                        a = num2 % 10;
                        num2 = num2 / 10;
                        b = num2 % 10;
                        if ((a == b) && (a == c)) { // если две цифры во втором числе одинаковые и совпадают с одной из трех найденных
                            return true;            // выводим true
                        }
                    }
                }
            }
        }
        return false;
    }

    public static int zadacha10(String str, char a) {
        String substr = "";
        String result = "";
        int index1;
        int index2;
        int n = str.length();
        int check = 0;
        while (n > 1) {                                     // пока в строке есть элементы
            index1 = str.indexOf(a);                        // находим место элемента, заданного по условию
            if (index1 == -1) break;                        // если не найден элемент, то выходим из цикла
            str = str.substring(index1 + 1, str.length());  // исключаем данный элемент из строки
            index2 = str.indexOf(a);                        // находим следующий номер заданного элемента
            if (index2 == -1) break;
            substr += str.substring(0, index2);             // в новую строку записываем элементы, находящиеся между заданными элементами
            str = str.substring(index2 + 1, str.length());  // из изначальной строки исключаем все элементы, до места, на котором стоял второй элемент, также исключаем этот элемент
            n -= (index1 + index2);                         // количество элементов в строке уменьшаем на число исключенных
        }
        if (substr.length() == 0) {                         // если ни один элемент не был добавлен в новую строку, то выводим 0
            return 0;
        }
        result += substr.charAt(0);                         // записываем первый элемент полученной строки в новую строку
        for (int i = 1; i < substr.length(); i++) {         // каждый элемент полученной строки сравниваем с элементами, стоящими до него
            for (int j = 0; j < i; j++) {                   
                if (substr.charAt(i) == substr.charAt(j)) { // если элемент повторяется, то в check записываем 1
                    check = 1;
                    break;
                }
            }
            if (check == 0) {                               // если элемент встречается один раз в строке, то записываем его в новую строку
                result += substr.charAt(i);                 // таким образом мы получаем строку из неповторяющихся элементов строки
            }
            check = 0;
        }
        return result.length();                             // выводим количество неповторяющихся элементов
    }
}
